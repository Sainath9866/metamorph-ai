import { NextResponse } from 'next/server';
import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs/promises';
import path from 'path';

const execAsync = promisify(exec);

export async function POST(request: Request) {
    try {
        const { repository, mission, github_token } = await request.json();

        if (!repository || !mission) {
            return NextResponse.json(
                { error: 'Repository and mission are required' },
                { status: 400 }
            );
        }

        // Validate METAMORPH_API_KEY is configured
        if (!process.env.METAMORPH_API_KEY) {
            return NextResponse.json(
                { error: 'MetaMorph API key not configured' },
                { status: 500 }
            );
        }

        const [owner, repo] = repository.split('/');
        const tempDir = path.join('/tmp', `metamorph-${Date.now()}`);

        try {
            // Clone the repository
            await execAsync(`git clone https://github.com/${repository}.git ${tempDir}`);

            // Run Cline with MetaMorph's API key
            const { stdout, stderr } = await execAsync(
                `cd ${tempDir} && npx cline@latest --autonomous --task "${mission}" --max-iterations 5`,
                {
                    env: {
                        ...process.env,
                        ANTHROPIC_API_KEY: process.env.METAMORPH_API_KEY,
                    },
                    timeout: 300000, // 5 minutes
                }
            );

            console.log('Cline output:', stdout);
            if (stderr) console.error('Cline errors:', stderr);

            // Check if changes were made
            const { stdout: gitStatus } = await execAsync(`cd ${tempDir} && git status --porcelain`);

            if (!gitStatus.trim()) {
                // No changes made
                await fs.rm(tempDir, { recursive: true, force: true });
                return NextResponse.json({
                    success: true,
                    message: 'No changes needed',
                    changes_made: false,
                });
            }

            // Create a new branch
            const branchName = `metamorph-fixes-${Date.now()}`;
            await execAsync(`cd ${tempDir} && git checkout -b ${branchName}`);

            // Commit changes
            await execAsync(`cd ${tempDir} && git add -A`);
            await execAsync(`cd ${tempDir} && git commit -m "fix: Auto-heal code issues via MetaMorph AI"`);

            // Push to repo (requires token)
            if (github_token) {
                await execAsync(
                    `cd ${tempDir} && git push https://${github_token}@github.com/${repository}.git ${branchName}`
                );

                // Create PR via GitHub API
                const prResponse = await fetch(`https://api.github.com/repos/${repository}/pulls`, {
                    method: 'POST',
                    headers: {
                        Authorization: `Bearer ${github_token}`,
                        Accept: 'application/vnd.github.v3+json',
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        title: 'ü§ñ MetaMorph AI: Automated Code Fixes',
                        body: `## ü§ñ Autonomous Code Healing\n\nThis PR was automatically generated by MetaMorph AI.\n\n**Mission:** ${mission}\n\n### Changes Made:\n- Analyzed code issues\n- Applied automated fixes\n- Evaluated code quality\n\nPowered by MetaMorph AI üõ°Ô∏è`,
                        head: branchName,
                        base: 'main',
                    }),
                });

                const prData = await prResponse.json();

                // Cleanup
                await fs.rm(tempDir, { recursive: true, force: true });

                return NextResponse.json({
                    success: true,
                    message: 'Healing complete, PR created',
                    changes_made: true,
                    pr_url: prData.html_url,
                    pr_number: prData.number,
                });
            } else {
                // No token provided, can't create PR
                await fs.rm(tempDir, { recursive: true, force: true });

                return NextResponse.json({
                    success: true,
                    message: 'Healing complete (changes made but no token to create PR)',
                    changes_made: true,
                });
            }

        } catch (error) {
            // Cleanup on error
            try {
                await fs.rm(tempDir, { recursive: true, force: true });
            } catch { }

            throw error;
        }

    } catch (error) {
        console.error('Healing execution error:', error);
        return NextResponse.json(
            {
                success: false,
                error: error instanceof Error ? error.message : 'Healing failed',
            },
            { status: 500 }
        );
    }
}
